# -*- coding: utf-8 -*-
"""final_code.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1hdxMrmk4P3xpt6NLbhur8rND_ShAFZH_
"""

import cv2
import numpy as np
from google.colab.patches import cv2_imshow
from google.colab import drive

drive.mount('/content/drive')

# ðŸ”¹ Function to match SIFT features & compute homography
def sift_match_and_homography(img1, img2):
    sift = cv2.SIFT_create()
    kp1, des1 = sift.detectAndCompute(img1, None)
    kp2, des2 = sift.detectAndCompute(img2, None)

    bf = cv2.BFMatcher()
    matches = bf.knnMatch(des1, des2, k=2)

    good_matches = [m for m, n in matches if m.distance < 0.75 * n.distance]

    pts1 = np.float32([kp1[m.queryIdx].pt for m in good_matches])
    pts2 = np.float32([kp2[m.trainIdx].pt for m in good_matches])

    H, _ = cv2.findHomography(pts1, pts2, cv2.RANSAC, 5.0)
    match_vis = cv2.drawMatches(img1, kp1, img2, kp2, good_matches, None, flags=2)

    return H, match_vis

# ðŸ”¹ Function to create a smooth feathered mask
def create_feathered_mask(image, blur_size=51):  # Use an odd number
    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
    _, mask_bin = cv2.threshold(gray, 1, 255, cv2.THRESH_BINARY)

    # Ensure blur_size is always odd
    if blur_size % 2 == 0:
        blur_size += 1

    return cv2.GaussianBlur(mask_bin, (blur_size, blur_size), 0).astype(np.float32) / 255.0


# ðŸ”¹ Function to normalize brightness
def normalize_brightness(img, ref_img):
    img_lab = cv2.cvtColor(img, cv2.COLOR_BGR2LAB)
    ref_lab = cv2.cvtColor(ref_img, cv2.COLOR_BGR2LAB)

    l_mean_img = np.mean(img_lab[:, :, 0])
    l_mean_ref = np.mean(ref_lab[:, :, 0])

    correction = (l_mean_ref / l_mean_img)
    img_lab[:, :, 0] = np.clip(img_lab[:, :, 0] * correction, 0, 255).astype(np.uint8)

    return cv2.cvtColor(img_lab, cv2.COLOR_LAB2BGR)

# ðŸ”¹ Function to blend images using masks
def mask_blend(base, warped, mask):
    base = base.astype(np.uint8)
    warped = warped.astype(np.uint8)

    inv_mask = 1 - mask
    base_bg = (base * inv_mask[..., None]).astype(np.uint8)
    warped_fg = (warped * mask[..., None]).astype(np.uint8)

    return cv2.add(base_bg, warped_fg)

# ðŸ”¹ Functions to build Gaussian and Laplacian pyramids
def build_gaussian_pyramid(img, levels):
    G = [img]
    for _ in range(levels):
        G.append(cv2.pyrDown(G[-1]))
    return G

def build_laplacian_pyramid(G):
    L = [G[-1]]
    for i in range(len(G) - 1, 0, -1):
        GE = cv2.pyrUp(G[i], dstsize=(G[i - 1].shape[1], G[i - 1].shape[0]))
        L.append(cv2.subtract(G[i - 1], GE))
    return L[::-1]

# ðŸ”¹ Function for multi-band blending
def multi_laplacian_blend(imgs, masks, levels=5):
    GP, MP, LP = [], [], []
    n = len(imgs)

    # Build pyramids
    for i in range(n):
        GP.append(build_gaussian_pyramid(imgs[i], levels))
        MP.append(build_gaussian_pyramid(masks[i], levels))
        LP.append(build_laplacian_pyramid(GP[i]))

    BL = []
    for lev in range(len(GP[0])):
        ws = np.zeros_like(MP[0][lev], dtype=np.float32)

        for j in range(n):
            resized_mask = cv2.resize(MP[j][lev], (MP[0][lev].shape[1], MP[0][lev].shape[0]))
            ws += resized_mask

        ws = np.clip(ws, 1e-5, 1)  # Avoid division errors

        out = np.zeros_like(LP[0][lev], dtype=np.float32)
        for j in range(n):
            w = cv2.resize(MP[j][lev], (LP[0][lev].shape[1], LP[0][lev].shape[0])) / ws
            out += LP[j][lev].astype(np.float32) * w[..., None]

        BL.append(out)

    result = BL[-1]
    for i in range(len(BL) - 2, -1, -1):
        up = cv2.pyrUp(result, dstsize=(BL[i].shape[1], BL[i].shape[0]))
        result = up + BL[i]

    return np.clip(result, 0, 255).astype(np.uint8)

# ðŸ”¹ Load images
left = cv2.imread('/content/drive/MyDrive/IMG-20250206-WA0006.jpg')
middle = cv2.imread('/content/drive/MyDrive/IMG-20250206-WA0005.jpg')
right = cv2.imread('/content/drive/MyDrive/IMG-20250206-WA0004.jpg')

# ðŸ”¹ Normalize brightness
left = normalize_brightness(left, middle)
right = normalize_brightness(right, middle)

# ðŸ”¹ Prepare canvas
out_h, out_w = 1312, 1608
padded_middle = cv2.copyMakeBorder(middle, 0, out_h - middle.shape[0], 0, out_w - middle.shape[1], cv2.BORDER_CONSTANT, value=0)

# ðŸ”¹ Compute homographies
H_lm, vis_lm = sift_match_and_homography(left, middle)
cv2_imshow(vis_lm)
warp_left = cv2.warpPerspective(left, H_lm, (out_w, out_h))

H_rm, vis_rm = sift_match_and_homography(right, middle)
cv2_imshow(vis_rm)
warp_right = cv2.warpPerspective(right, H_rm, (out_w, out_h))

# ðŸ”¹ Generate feathered masks
ml = create_feathered_mask(warp_left)
mm = create_feathered_mask(padded_middle)
mr = create_feathered_mask(warp_right)

# ðŸ”¹ Step 3: Mask Blending
step1_mask = mask_blend(padded_middle, warp_left, ml)
final_mask = mask_blend(step1_mask, warp_right, mr)

cv2_imshow(final_mask)

# ðŸ”¹ Step 4: Laplacian Pyramid Blending
imgs = [warp_left, padded_middle, warp_right]
masks = [ml, mm, mr]
laplacian_result = multi_laplacian_blend(imgs, masks, levels=5)

cv2_imshow(laplacian_result)
cv2.waitKey(0)
cv2.destroyAllWindows()
